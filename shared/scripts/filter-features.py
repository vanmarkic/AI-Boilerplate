#!/usr/bin/env python3
"""Filter features by tier for build-time exclusion.

Reads manifest.yaml from each feature directory. Copies only features
whose tier <= target tier to the output directory.

Usage:
  filter-features.py --tier=2 --src=backend/features --dest=build/features
  filter-features.py --tier=1 --src=frontend/src/app/features --dest=build/features --frontend
"""
import argparse
import shutil
import sys
from pathlib import Path

import yaml


def get_feature_tier(feature_dir: Path) -> int:
    """Read tier from manifest.yaml. Default to 1 if no manifest."""
    manifest = feature_dir / "manifest.yaml"
    if not manifest.exists():
        return 1
    with open(manifest) as f:
        data = yaml.safe_load(f)
    return data.get("tier", 1)


def filter_features(src: Path, dest: Path, max_tier: int) -> list[str]:
    """Copy only features with tier <= max_tier."""
    dest.mkdir(parents=True, exist_ok=True)
    included: list[str] = []
    excluded: list[str] = []

    for feature_dir in sorted(src.iterdir()):
        if not feature_dir.is_dir() or feature_dir.name.startswith("_"):
            continue

        tier = get_feature_tier(feature_dir)
        if tier <= max_tier:
            shutil.copytree(feature_dir, dest / feature_dir.name)
            included.append(f"  ✓ {feature_dir.name} (tier {tier})")
        else:
            excluded.append(f"  ✗ {feature_dir.name} (tier {tier}) — EXCLUDED")

    print(f"Building for Tier {max_tier}:")
    print(f"\nIncluded ({len(included)}):")
    print("\n".join(included))
    if excluded:
        print(f"\nExcluded ({len(excluded)}):")
        print("\n".join(excluded))
    return [d.name for d in dest.iterdir() if d.is_dir()]


def generate_backend_init(dest: Path, features: list[str]) -> None:
    """Generate features/__init__.py that imports only included routers."""
    imports = []
    registrations = []
    for name in features:
        router_file = dest / name / f"{name}_router.py"
        if router_file.exists():
            imports.append(f"from features.{name}.{name}_router import router as {name}_router")
            registrations.append(f'    app.include_router({name}_router)')

    init_content = f'''"""Auto-generated feature registration. DO NOT EDIT manually.
Generated by filter-features.py for the current build tier."""
from fastapi import FastAPI

{chr(10).join(imports)}


def register_features(app: FastAPI) -> None:
    """Register all feature routers for this build tier."""
{chr(10).join(registrations)}
'''
    (dest / "__init__.py").write_text(init_content)


def generate_frontend_routes(dest: Path, features: list[str]) -> None:
    """Generate app.routes.generated.ts for included features."""
    route_imports = []

    for name in features:
        kebab = name.replace("_", "-")
        routes_file = dest / kebab / f"{kebab}.routes.ts"
        if routes_file.exists():
            const_name = name.upper() + "_ROUTES"
            route_imports.append(
                f"  {{ path: '{kebab}', loadChildren: () => "
                f"import('./features/{kebab}/{kebab}.routes').then(m => m.{const_name}) }}"
            )

    content = f'''// Auto-generated routes. DO NOT EDIT manually.
// Generated by filter-features.py for the current build tier.
import {{ Routes }} from '@angular/router';

export const generatedRoutes: Routes = [
{chr(10).join('  ' + r + ',' for r in route_imports)}
];
'''
    (dest.parent / "app.routes.generated.ts").write_text(content)


def main() -> int:
    parser = argparse.ArgumentParser()
    parser.add_argument("--tier", type=int, required=True)
    parser.add_argument("--src", type=Path, required=True)
    parser.add_argument("--dest", type=Path, required=True)
    parser.add_argument("--frontend", action="store_true")
    args = parser.parse_args()

    if not args.src.exists():
        print(f"Source directory not found: {args.src}")
        return 1

    features = filter_features(args.src, args.dest, args.tier)

    if args.frontend:
        generate_frontend_routes(args.dest, features)
    else:
        generate_backend_init(args.dest, features)

    return 0


if __name__ == "__main__":
    sys.exit(main())
